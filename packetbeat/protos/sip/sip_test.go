// +build !integration

package sip

import (
/*    "bytes" */
    "net"
/*    "regexp"
    "strings"*/
    "testing"
    "time"

    "github.com/stretchr/testify/assert"

    "github.com/elastic/beats/libbeat/beat"
    "github.com/elastic/beats/libbeat/common"
    "github.com/elastic/beats/libbeat/logp"
    "github.com/elastic/beats/packetbeat/protos"
)

// Test Constants
const (
    serverIP   = "192.168.0.1"
    serverPort = 5060
    clientIP   = "10.0.0.1"
    clientPort = 34898
)

// DnsTestMessage holds the data that is expected to be returned when parsing
// the raw DNS layer payloads for the request and response packet.
type dnsTestMessage struct {
    id          uint16
    opcode      string
    flags       []string
    rcode       string
    qClass      string
    qType       string
    qName       string
    qEtld       string
    answers     []string
    authorities []string
    additionals []string
    request     []byte
    response    []byte
}

// Request and response addresses.
var (
    forward = common.NewIPPortTuple(4,
        net.ParseIP(serverIP), serverPort,
        net.ParseIP(clientIP), clientPort)
    reverse = common.NewIPPortTuple(4,
        net.ParseIP(clientIP), clientPort,
        net.ParseIP(serverIP), serverPort)
)

var (
    // An array of all test messages.
    messages = []dnsTestMessage{
        elasticA,
    }

    elasticA = dnsTestMessage{

        id:      8529,
        opcode:  "QUERY",
        flags:   []string{"rd", "ra"},
        rcode:   "NOERROR",
        qClass:  "IN",
        qType:   "A",
        qName:   "elastic.co.",
        qEtld:   "elastic.co.",
        answers: []string{"54.148.130.30", "54.69.104.66"},
        request: []byte{
            0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x20, 0x73, 0x69, 0x70, 0x3a, 0x36, 0x35, 0x30, 0x35, 0x35,
            0x35, 0x30, 0x32, 0x35, 0x32, 0x40, 0x65, 0x78, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x63, 0x6f,
            0x6d, 0x3a, 0x35, 0x30, 0x36, 0x30, 0x20, 0x53, 0x49, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x0d, 0x0a,
            0x56, 0x69, 0x61, 0x3a, 0x20, 0x53, 0x49, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x2f, 0x55, 0x44, 0x50,
            0x20, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32, 0x35, 0x32,
            0x3a, 0x35, 0x30, 0x36, 0x30, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7a, 0x39, 0x68,
            0x47, 0x34, 0x62, 0x4b, 0x2d, 0x32, 0x33, 0x36, 0x33, 0x2d, 0x31, 0x2d, 0x30, 0x0d, 0x0a, 0x46,
            0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x73, 0x69, 0x70, 0x70, 0x20, 0x3c, 0x73, 0x69, 0x70, 0x3a, 0x73,
            0x69, 0x70, 0x70, 0x40, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e,
            0x32, 0x35, 0x32, 0x3a, 0x35, 0x30, 0x36, 0x30, 0x3e, 0x3b, 0x74, 0x61, 0x67, 0x3d, 0x32, 0x33,
            0x36, 0x33, 0x53, 0x49, 0x50, 0x70, 0x54, 0x61, 0x67, 0x30, 0x30, 0x31, 0x0d, 0x0a, 0x54, 0x6f,
            0x3a, 0x20, 0x73, 0x75, 0x74, 0x20, 0x3c, 0x73, 0x69, 0x70, 0x3a, 0x36, 0x35, 0x30, 0x35, 0x35,
            0x35, 0x30, 0x32, 0x35, 0x32, 0x40, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32,
            0x32, 0x2e, 0x35, 0x39, 0x3a, 0x35, 0x30, 0x36, 0x30, 0x3e, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c,
            0x2d, 0x49, 0x44, 0x3a, 0x20, 0x31, 0x2d, 0x32, 0x33, 0x36, 0x33, 0x40, 0x31, 0x39, 0x32, 0x2e,
            0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32, 0x35, 0x32, 0x0d, 0x0a, 0x43, 0x53, 0x65,
            0x71, 0x3a, 0x20, 0x31, 0x20, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x0d, 0x0a, 0x43, 0x6f, 0x6e,
            0x74, 0x61, 0x63, 0x74, 0x3a, 0x20, 0x73, 0x69, 0x70, 0x3a, 0x73, 0x69, 0x70, 0x70, 0x40, 0x31,
            0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32, 0x35, 0x32, 0x3a, 0x35,
            0x30, 0x36, 0x30, 0x0d, 0x0a, 0x4d, 0x61, 0x78, 0x2d, 0x46, 0x6f, 0x72, 0x77, 0x61, 0x72, 0x64,
            0x73, 0x3a, 0x20, 0x37, 0x30, 0x0d, 0x0a, 0x53, 0x75, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x3a, 0x20,
            0x50, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x54, 0x65, 0x73, 0x74,
            0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x54, 0x79, 0x70, 0x65, 0x3a, 0x20,
            0x61, 0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x73, 0x64, 0x70, 0x0d,
            0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a,
            0x20, 0x20, 0x20, 0x31, 0x34, 0x31, 0x0d, 0x0a, 0x0d, 0x0a, 0x76, 0x3d, 0x30, 0x0d, 0x0a, 0x6f,
            0x3d, 0x75, 0x73, 0x65, 0x72, 0x31, 0x20, 0x35, 0x33, 0x36, 0x35, 0x35, 0x37, 0x36, 0x35, 0x20,
            0x32, 0x33, 0x35, 0x33, 0x36, 0x38, 0x37, 0x36, 0x33, 0x37, 0x20, 0x49, 0x4e, 0x20, 0x49, 0x50,
            0x34, 0x20, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32, 0x35,
            0x32, 0x0d, 0x0a, 0x73, 0x3d, 0x2d, 0x0d, 0x0a, 0x63, 0x3d, 0x49, 0x4e, 0x20, 0x49, 0x50, 0x34,
            0x20, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32, 0x35, 0x32,
            0x0d, 0x0a, 0x74, 0x3d, 0x30, 0x20, 0x30, 0x0d, 0x0a, 0x6d, 0x3d, 0x61, 0x75, 0x64, 0x69, 0x6f,
            0x20, 0x36, 0x30, 0x30, 0x30, 0x20, 0x52, 0x54, 0x50, 0x2f, 0x41, 0x56, 0x50, 0x20, 0x30, 0x0d,
            0x0a, 0x61, 0x3d, 0x72, 0x74, 0x70, 0x6d, 0x61, 0x70, 0x3a, 0x30, 0x20, 0x50, 0x43, 0x4d, 0x55,
            0x2f, 0x38, 0x30, 0x30, 0x30, 0x0d, 0x0a,
        },
        response: []byte{
            0x53, 0x49, 0x50, 0x2f, 0x32, 0x2e, 0x30, 0x20, 0x31, 0x30, 0x30, 0x20, 0x54, 0x72, 0x79, 0x69,
            0x6e, 0x67, 0x0d, 0x0a, 0x56, 0x69, 0x61, 0x3a, 0x20, 0x53, 0x49, 0x50, 0x2f, 0x32, 0x2e, 0x30,
            0x2f, 0x55, 0x44, 0x50, 0x20, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32,
            0x2e, 0x32, 0x35, 0x32, 0x3a, 0x35, 0x30, 0x36, 0x30, 0x3b, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76,
            0x65, 0x64, 0x3d, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32,
            0x35, 0x32, 0x3b, 0x62, 0x72, 0x61, 0x6e, 0x63, 0x68, 0x3d, 0x7a, 0x39, 0x68, 0x47, 0x34, 0x62,
            0x4b, 0x2d, 0x32, 0x33, 0x36, 0x33, 0x2d, 0x31, 0x2d, 0x30, 0x0d, 0x0a, 0x52, 0x65, 0x63, 0x6f,
            0x72, 0x64, 0x2d, 0x52, 0x6f, 0x75, 0x74, 0x65, 0x3a, 0x20, 0x3c, 0x73, 0x69, 0x70, 0x3a, 0x31,
            0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x35, 0x39, 0x3a, 0x35, 0x30,
            0x35, 0x38, 0x3b, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x3d, 0x54, 0x43, 0x50,
            0x3b, 0x6c, 0x72, 0x3e, 0x0d, 0x0a, 0x52, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x2d, 0x52, 0x6f, 0x75,
            0x74, 0x65, 0x3a, 0x20, 0x3c, 0x73, 0x69, 0x70, 0x3a, 0x41, 0x63, 0x51, 0x42, 0x65, 0x79, 0x4d,
            0x7a, 0x4e, 0x43, 0x40, 0x63, 0x77, 0x2d, 0x61, 0x69, 0x6f, 0x3a, 0x35, 0x30, 0x36, 0x30, 0x3b,
            0x74, 0x72, 0x61, 0x6e, 0x73, 0x70, 0x6f, 0x72, 0x74, 0x3d, 0x55, 0x44, 0x50, 0x3b, 0x6c, 0x72,
            0x3e, 0x0d, 0x0a, 0x43, 0x61, 0x6c, 0x6c, 0x2d, 0x49, 0x44, 0x3a, 0x20, 0x31, 0x2d, 0x32, 0x33,
            0x36, 0x33, 0x40, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32,
            0x35, 0x32, 0x0d, 0x0a, 0x46, 0x72, 0x6f, 0x6d, 0x3a, 0x20, 0x22, 0x73, 0x69, 0x70, 0x70, 0x22,
            0x20, 0x3c, 0x73, 0x69, 0x70, 0x3a, 0x73, 0x69, 0x70, 0x70, 0x40, 0x31, 0x39, 0x32, 0x2e, 0x31,
            0x36, 0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x32, 0x35, 0x32, 0x3e, 0x3b, 0x74, 0x61, 0x67, 0x3d,
            0x32, 0x33, 0x36, 0x33, 0x53, 0x49, 0x50, 0x70, 0x54, 0x61, 0x67, 0x30, 0x30, 0x31, 0x0d, 0x0a,
            0x54, 0x6f, 0x3a, 0x20, 0x22, 0x73, 0x75, 0x74, 0x22, 0x20, 0x3c, 0x73, 0x69, 0x70, 0x3a, 0x36,
            0x35, 0x30, 0x35, 0x35, 0x35, 0x30, 0x32, 0x35, 0x32, 0x40, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36,
            0x38, 0x2e, 0x31, 0x32, 0x32, 0x2e, 0x35, 0x39, 0x3e, 0x0d, 0x0a, 0x43, 0x53, 0x65, 0x71, 0x3a,
            0x20, 0x31, 0x20, 0x49, 0x4e, 0x56, 0x49, 0x54, 0x45, 0x0d, 0x0a, 0x43, 0x6f, 0x6e, 0x74, 0x65,
            0x6e, 0x74, 0x2d, 0x4c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x3a, 0x20, 0x20, 0x30, 0x0d, 0x0a, 0x0d,
            0x0a,
        },
    }
)

type eventStore struct {
    events []beat.Event
}

func (e *eventStore) publish(event beat.Event) {
    e.events = append(e.events, event)
}

func (e *eventStore) empty() bool {
    return len(e.events) == 0
}

func newSIP(store *eventStore, verbose bool) *sipPlugin {
    level := logp.WarnLevel
    if verbose {
        level = logp.DebugLevel
    }
    logp.DevelopmentSetup(
        logp.WithLevel(level),
        logp.WithSelectors("sip"),
    )

    callback := func(beat.Event) {}
    if store != nil {
        callback = store.publish
    }

    cfg, _ := common.NewConfigFrom(map[string]interface{}{
        "ports":               []int{serverPort},
        "include_authorities": true,
        "include_additionals": true,
        "send_request":        true,
        "send_response":       true,
    })
    sip, err := New(false, callback, cfg)
    if err != nil {
        panic(err)
    }

    return sip.(*sipPlugin)
}

func newPacket(t common.IPPortTuple, payload []byte) *protos.Packet {
    return &protos.Packet{
        Ts:      time.Now(),
        Tuple:   t,
        Payload: payload,
    }
}

// Verify that an empty packet is safely handled (no panics).
func TestParseUdp_emptyPacket(t *testing.T) {
    store := &eventStore{}
    sip := newSIP(store, testing.Verbose())
    packet := newPacket(forward, []byte{})
    sip.ParseUDP(packet)
    assert.Empty(t, sip.transactions.Size(), "There should be no transactions.")
    assert.True(t, store.empty(), "No result should have been published.")
}

// Verify that a malformed packet is safely handled (no panics).
func TestParseUdp_malformedPacket(t *testing.T) {
    sip := newSIP(nil, testing.Verbose())
    garbage := []byte{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13}
    packet := newPacket(forward, garbage)
    sip.ParseUDP(packet)
    assert.Empty(t, sip.transactions.Size(), "There should be no transactions.")

    // As a future addition, a malformed message should publish a result.
}

// Verify that the lone request packet is parsed.
func TestParseUdp_requestPacket(t *testing.T) {
    store := &eventStore{}
    sip := newSIP(store, testing.Verbose())
    packet := newPacket(forward, elasticA.request)
    sip.ParseUDP(packet)
    assert.Equal(t, 1, sip.transactions.Size(), "There should be one transaction.")
    assert.True(t, store.empty(), "No result should have been published.")
}


